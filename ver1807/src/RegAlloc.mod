(*!m2pim+mocka*)

(* ------------------------------------------------------------------------ *
 * MOCKA Modula-2 Compiler System, Version 1807                             *
 *                                                                          *
 * Copyright (C) 1988-2000 by                                               *
 *  GMD Gesellschaft fuer Mathematik und Datenverarbeitung,                 *
 *  Ehemalige GMD Forschungsstelle an der Uni Karlsruhe;                    *
 *  [EN] German National Research Center for Computer Science,              *
 *  Former GMD Research Lab at the University of Karlsruhe.                 *
 *                                                                          *
 * Copyright (C) 2001-2018 by                                               *
 *  Fraunhofer-Gesellschaft zur Foerderung der angewandten Forschung;       *
 *  [EN] Fraunhofer Society for the Advancement of Applied Research.        *
 * ------------------------------------------------------------------------ *)

IMPLEMENTATION MODULE RegAlloc;

(* ************************************************************************ *
 *                  This module was generated by BEG V1.84                  *
 * ************************************************************************ *)

(******* empty insertion IpInOut *******)
 FROM    InOut IMPORT Write, WriteLn, WriteInt, WriteCard, WriteString;
 IMPORT IR;
 FROM IR IMPORT Expression;
 FROM IR IMPORT NonTerminal, Rule, Register,
      RegisterSet, MaxPscArity, OptRegAlloc;
 FROM GcgTab IMPORT RegKind, RuleDescr, RegDestroy;
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(******* empty insertion IpRegAlloc_i *******)
 PROCEDURE  RegAllo ( e : Expression; localavail : RegisterSet );
 VAR    
        ActSpilllocation : Spilllocation;
 PROCEDURE NewSpilllocation () : Spilllocation;
 BEGIN
    ActSpilllocation := ActSpilllocation+1;
    RETURN (ActSpilllocation);
 END NewSpilllocation;
 
 
 PROCEDURE ActionRestore   (a : AllocIndex; preg : Register;
 			   pspilllocation : Spilllocation);
 BEGIN
    WITH allocation [a] DO
       num := num+1;
       WITH a[num] DO 
 	   action := aRestore;
 	   regto  := preg;
	   spilllocation := pspilllocation;
      END;
   END;
 END ActionRestore;

 PROCEDURE ActionLr   (a : AllocIndex; pregto, pregfrom : Register);
 BEGIN
 (*   WriteString ('******************************* LR'); WriteLn;*)
    WITH allocation [a] DO
      num := num+1;
      WITH a[num] DO 
 	 action := aLr;
 	 regto  := pregto;
 	 regfrom:= pregfrom;
       END;
    END;
 END ActionLr;
 
 PROCEDURE Take (s : RegisterSet) : Register;
(******* empty insertion IpProcTake *******)
 VAR r : Register;
     c : CARDINAL;
     bs : BITSET;
 BEGIN
  bs := s[ORD(lowpriority) DIV 32];  (* he 8/91 *)
     EXCL (s[0], ORD(lowpriority));
;                       (* he 8/91 *)
    IF s[0]<>{}   THEN
      c := 0;
      WHILE NOT (c IN s[0]) DO INC(c); END;
      r:= VAL (Register, c+0);
         INCL (UsedReg[0], ORD(r));
;
      RETURN (r);
   END;
  IF ORD(lowpriority) MOD 32 IN bs THEN  (* he 8/91 *)
        INCL (UsedReg[0], ORD(lowpriority));
;
     RETURN (lowpriority);                              (* he 8/91 *)
  END;                                                  (* he 8/91 *)
  (*************** Compiler Error ******************)
  (******** register allocation not possible *******)
  WriteString ('Registerallocation not possible'); WriteLn;
  IR.Error('internal error');
  c:=0; c:=c DIV c; HALT;
 END Take;
 
 
 
 PROCEDURE RegAllocExpr (
                       e : Expression; rule : Rule;
 			first,
                       second,
                       third      : RegisterSet;
 			VAR oreg    : Register;
 			VAR sp     : Spilllocation;
 			VAR Change : RegisterSet);
 (* Perform Register allocation for e                                 *)
 (* reg is the result register or if reg=RegNil the result is in      *)
 (* memory. Then sp contains the number of the spilllocation.         *)
 (* It is tried to put the result in a register contained in first    *)
 (* It that is not possible second and third are tried. If everything *)
 (* else fails the result is spilled                                  *)
 
 VAR airegister  : AllocIndex;
     change, changelocal : RegisterSet;
 
  PROCEDURE RegAllocAdrMode (e : Expression; rule : Rule);
 
 VAR nextrule : Rule;
     i        : SHORTCARD;
     path     : CARDINAL;
     f        : Expression;
     av, av1, av2, av3 : RegisterSet;
     aiact    : AllocIndex;
     r,r1     : Register;
     s        : Spilllocation; 
     ch       : RegisterSet;
     ga       : IR.ExprAttributes;
 BEGIN
    IF ai >= MAX(AllocIndex) THEN
	(*************** Compiler Error ******************)
       (************* expression too complex ************)
	IR.Error('expression too complex');
       i:=0; i:=i DIV i; HALT;
    END;
    aiact := ai;
    allocation[aiact].num := 0;
    allocation[aiact].actionafter := FALSE;
    ai := ai+1; 
    WITH RuleDescr [rule] DO
       FOR i:=pscarity TO 1 BY -1 DO
        f:=e; path := op[i].path;
        WHILE path#0 DO 
           f:=f^.son [ path MOD 16 ];
           path := path DIV 16;
        END;
 
        nextrule := f^.gcg^.rule[op[i].nt];
        CASE  RuleDescr [nextrule].register OF 
          RKRegister, RKCalc :       (* he 3/91 *)
                    av3[0] := BITSET (-1)-change[0];      
;
           IF op[i].calc THEN
              ga := e^.gcg;
              CASE rule OF
              END;
                   av2[0]:={};
;
                 INCL (av2[0], ORD(r));
;
                 INCL (localavail[0], ORD(r));
;
                    av1[0]:=av2[0];      
;
              lowpriority := r;
           ELSE
                    av2[0]:=av3[0]*op[i].regs[0];      
              IF (i=target) OR (i=result) THEN 
                 IF closuretarget THEN 
                    IR.RegClosure (first,first);
                          av1[0]:=first[0]*av2[0];      
                    IF ( (localavail[0]*av1[0]={})) THEN
                       IR.RegClosure (second,second);
                             av1[0]:=second[0]*av2[0];      
                       IF ( (localavail[0]*av1[0]={})) THEN 
                          IR.RegClosure (third,third);
                                av1[0]:=third[0]*av2[0];      
                       END;
                    END;
                 ELSE
                          av1[0]:=first[0]*av2[0];      
                    IF ( (localavail[0]*av1[0]={})) THEN
                             av1[0]:=second[0]*av2[0];      
                       IF ( (localavail[0]*av1[0]={})) THEN 
                                av1[0]:=third[0]*av2[0];      
                       END;
                    END;
                 END;
              ELSE
                 av1 := av2;
              END;
           END;
 
           RegAllocExpr (
                         f, nextrule,
                         av1,
                         av2,
                         av3,
                         r,
                         s,
                         ch);
                 change[0]:=change[0]+ch[0];      
 
           IF (i=target) OR (i=result) THEN 
              IF ((i=result) AND (r # RegNil)) OR (   (ORD(r) IN av1[0]) AND    (ORD(r) IN localavail[0])) THEN
                 r1 := r;
              ELSE
                       av[0] :=lav[0]-changelocal[0];      
                       av[0]:=av[0]*op[i].regs[0];      
                 IF NOT ( (av[0]*first[0]={})) THEN 
                          av[0]:=av[0]*first[0];      
                    r1:= Take (av);
                 ELSIF    (ORD(r) IN av[0]) THEN                (* he 8/91 *)
                    r1 := r;
                 ELSIF NOT ( (av[0]*second[0]={})) THEN 
                          av[0]:=av[0]*second[0];      
                    r1:= Take (av);
                 ELSIF NOT ( (av[0]*third[0]={})) THEN 
                          av[0]:=av[0]*third[0];      
                    r1:= Take (av);
                 ELSE
                    r1:= Take (av);
                 END;
              END;
           ELSE (* i#target *)
              IF (r=RegNil) OR NOT    (ORD(r) IN av2[0]) THEN 
                 IF op[i].calc THEN 
                    r1 := Take (av1);
                 ELSE 
                          av[0] :=lav[0]-changelocal[0];      
                          av[0]:=av[0]*op[i].regs[0];      
                    r1 := Take (av);
                 END; (* -- he 07/91 *)
              ELSE
                 r1 := r;
              END;
           END;
 
           IF r1#r THEN 
              IF r=RegNil THEN 
                 ActionRestore (airegister, r1, s);
              ELSE
                 ActionLr (airegister, r1, r);
              END;   (* he 12/91 *)
                    change[0]:=change[0]+RegDestroy[r1][0];      
           END;
 
           allocation [aiact] . op [i] := r1;
           IF (i=target) OR (i=result) THEN 
              IF closuretarget THEN 
                       av[0]:=RegDestroy[r1][0]*resregs[0];      
                 targetregister := Take (av);
              ELSE
                 targetregister := r1; 
              END;
           END;
                 changelocal[0]:=changelocal[0]+RegDestroy[r1][0];      
        | RKAdrmode : 
           RegAllocAdrMode (f, nextrule);
        ELSE 
           RegAllocExpr (
           		  f, nextrule,
                         av1,   (* dummy *)
                         av2,   (* dummy *)
                         av3,   (* dummy *)
                         r,   (* dummy *)
                         s,   (* dummy *)
                         ch);
                 change[0]:=change[0]+ch[0];      
        END;
       END;
    END;
 END RegAllocAdrMode;
 
 
 
 		  
 VAR    
      r,r1,targetregister : Register;
      av, lav             : RegisterSet;
      ga                  : IR.ExprAttributes;
      i                   : CARDINAL;
 BEGIN
    airegister := ai; allocation[airegister].num := 0;
    IF OptRegAlloc THEN 
       WriteString ('RegAlloc : ');
       WriteString ('Rule ='); WriteInt (rule,1); WriteLn;
       IF e#NIL THEN 
          IR.PrintAttributes (e^.attr^);
       ELSE 
          WriteString ('unknown attributes'); WriteLn;
       END;
       WriteString ('best   '); IR.PrintRegisterSet (first); WriteLn;
       WriteString ('medium '); IR.PrintRegisterSet (second); WriteLn;
       WriteString ('worst  '); IR.PrintRegisterSet (third); WriteLn;
    END;
 
         change[0]:={};
         changelocal[0]:={};
          lav[0]:=localavail[0];      
    RegAllocAdrMode (e,rule);
    
    sp := 0;
    WITH RuleDescr [rule] DO
       IF register=RKCalc THEN 
 	   ga:=e^.gcg;
          CASE rule OF 
          END;
             EXCL (localavail[0], ORD(r));
;
          IF    (ORD(r) IN third[0]) THEN 
	      oreg := r;
          ELSIF NOT ( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
 	            av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
             oreg := Take(av);                   (* he 08/91 *)
                   change[0]:=change[0]+RegDestroy[oreg][0];      
          ELSIF NOT ( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
 	            av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
             oreg := Take(av);                   (* he 08/91 *)
                   change[0]:=change[0]+RegDestroy[oreg][0];      
 	   ELSE
 	      sp := NewSpilllocation();
 	      oreg := RegNil;
          END;
          WITH allocation[airegister] DO
            spilllocation := sp; reg := r; regmove := oreg;  (* he 08/91 *)
            actionafter := (sp#0) OR (oreg#r);  (* he 08/91 *)
          END;
                Change[0]:=change[0]+changeregs[0];      
          RETURN; 
       END;

       IF register#RKRegister THEN
                Change[0]:=change[0]+changeregs[0];      
       ELSE 
                av[0]:=lav[0]*resregs[0];      
          IF (target#0) OR (result#0) THEN 
 	      IF    (ORD(targetregister) IN first[0]) OR
 	            (ORD(targetregister) IN second[0]) OR
 	            (ORD(targetregister) IN third[0]) THEN
 	         oreg := targetregister;
             ELSIF NOT ( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
 	               av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+RegDestroy[oreg][0];      
             ELSIF NOT ( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
 	               av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+RegDestroy[oreg][0];      
 	      ELSE
 	         sp := NewSpilllocation();
 	         oreg := RegNil;
 	      END;
 	      r := targetregister;
          ELSE
             IF unique THEN       av[0] :=av[0]-changelocal[0];      
; END;
             IF NOT ( (av[0]*first[0]={})) THEN 
 	               av[0]:=av[0]*first[0];      
 	         r := Take (av); oreg:=r;
             ELSIF NOT ( (av[0]*second[0]={})) THEN 
 	               av[0]:=av[0]*second[0];      
 	         r := Take (av); oreg:=r;
             ELSIF NOT ( (av[0]*third[0]={})) THEN 
 	               av[0]:=av[0]*third[0];      
 	         r := Take (av); oreg:=r;
             ELSIF NOT ( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
                r := Take(av);                      (* he 08/91 *)
 	               av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+RegDestroy[oreg][0];      
             ELSIF NOT ( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
                r := Take(av);                      (* he 08/91 *)
 	               av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+RegDestroy[oreg][0];      
             ELSE
 	         r := Take (av);
 	         oreg := RegNil;
 	         sp := NewSpilllocation();
             END;
          END;
          IF result=0 THEN
                   change[0]:=change[0]+RegDestroy[r][0];      
          END;
                Change[0]:=change[0]+changeregs[0];      
          WITH allocation[airegister] DO
             spilllocation := sp; reg := r; regmove := oreg;  (* he 08/91 *)
             actionafter := (sp#0) OR (oreg#r);               (* he 08/91 *)
          END;
       END;
       IF scrnum#0 THEN 
                lav[0] :=lav[0]-changelocal[0];      
          FOR i:=1 TO scrnum DO 
                   av[0]:=lav[0]*scrrs[i][0];      
             r := Take(av);
             allocation[airegister].scr[i] := r;
                   lav[0] :=lav[0]-RegDestroy[r][0];      
;
                   Change[0]:=Change[0]+RegDestroy[r][0];      
;
          END;
       END;
       IF OptRegAlloc THEN 
          WriteString ('Rule ='); WriteInt (rule,1); WriteLn;
          IF e#NIL THEN 
             IR.PrintAttributes (e^.attr^);
          ELSE 
             WriteString ('unknown attributes'); WriteLn;
          END;
          WriteString ('avail  '); IR.PrintRegisterSet (localavail); WriteLn;
          PrintAllocation (airegister);
       END;
    END;
 END RegAllocExpr;
 
 VAR r : Register;
     s : Spilllocation; 
     ch : RegisterSet;
     emptyset : RegisterSet;
     lowpriority : Register;   (* he 8/91 *)
 BEGIN
    lowpriority := RegNil;     (* he 8/91 *)
    ai:=1;
    ActSpilllocation := 1;
    IF e^.gcg^.stmtcost >= IR.infcost THEN 
       (* no code selected, do nothing *)
    ELSE
            emptyset[0]:={};
       RegAllocExpr (e,e^.gcg^.stmtrule,emptyset,emptyset,emptyset, r,s,ch);
    END;
 END RegAllo;
 
 
 
 PROCEDURE PrintAllocation (i : AllocIndex);
 VAR j : CARDINAL;
 BEGIN
    WriteString ('ALLOC: '); WriteInt (i,2); Write (' ');
    IR.PrintRegister( allocation[i].reg ); 
    IF allocation[i].actionafter THEN  (* ++ he 08/91 *)
       Write('/');
       IF allocation[i].spilllocation#0 THEN WriteInt(allocation[i].spilllocation,1); END;
       IF allocation[i].regmove#RegNil THEN IR.PrintRegister(allocation[i].regmove); END;
    END; (* -- he 08/91 *)
    Write(' ');
    FOR j:=1 TO MaxPscArity DO 
 
       IF (MIN(Register)<=allocation [i].op[j])
 	 AND (MAX(Register)>=allocation[i].op[j]) THEN 
 	 IR.PrintRegister (allocation[i].op[j]);
       END;
       Write (' ');
    END;
    WITH allocation [i] DO 
       FOR j:=1 TO num DO
 	 WITH a[j] DO 
 	    CASE action OF 
 	    |  aLr : WriteString ('LR  ');
 		     IR.PrintRegister (regto);
 		     WriteString ('<-');
 		     IR.PrintRegister (regfrom);
 	    |  aRestore :
 		     WriteString ('RESTORE ');
 		     IR.PrintRegister (reg);
 		     WriteString (' FROM ');
 		     WriteInt (spilllocation,1);
 	    END;
 	    Write (' ');
 	 END;
       END;
    END;
    WriteLn;
 END PrintAllocation;
 
 BEGIN
 END RegAlloc.
